
===============================================================================
ASP.NET PROJECT EXPORT
Generated: 09/18/2025 11:09:41
Project Path: C:\Users\kushal\source\repos\AvoidMagicNumbers
===============================================================================

DIRECTORY STRUCTURE:
===================

Folder PATH listing
Volume serial number is 9892-5BAD
C:\USERS\KUSHAL\SOURCE\REPOS\AVOIDMAGICNUMBERS
|   .gitattributes
|   .gitignore
|   AvoidMagicNumbers.slnx
|   Export-Project.ps1
|   README.md
|   
+---AntiPattern
|       AntiPattern.csproj
|       RoleAssignmentService_BadWay.cs
|       
+---DemonstrationConsole
|       DemonstrationConsole.csproj
|       Program.cs
|       
+---llm
|       dump.txt
|       
\---ModernApproach
        ModernApproach.csproj
        RoleAssignmentService_GoodWay.cs
        


FILE CONTENTS:
==============

================================================================================
FILE: AntiPattern\AntiPattern.csproj
SIZE: 0.21 KB
MODIFIED: 09/18/2025 10:31:58
================================================================================

<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net10.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>

</Project>



================================================================================
FILE: AntiPattern\RoleAssignmentService_BadWay.cs
SIZE: 3.38 KB
MODIFIED: 09/18/2025 10:55:43
================================================================================

// ============================================
// ANTI-PATTERN: Using Magic Numbers in Loops
// ============================================

namespace AntiPattern
{
    public class RoleAssignmentService_BadWay
    {
        private Dictionary<string, object> parameters = new Dictionary<string, object>();

        public void AssignStandardRoles(string userId, string departmentId, DateTime assignedDate)
        {
            // PROBLEM 1: Magic numbers in loop - what do 6 and 7 represent?
            for (int i = 6; i <= 7; i++)
            {
                string roleId = Guid.NewGuid().ToString();
                string assignmentId = Guid.NewGuid().ToString();
                string supervisorId = null;

                // PROBLEM 2: Building parameters inside loop with unclear logic
                parameters.Clear();
                parameters.Add("RoleId", roleId);
                parameters.Add("AssignmentId", assignmentId);
                parameters.Add("UserId", userId);
                parameters.Add("DepartmentId", departmentId);
                parameters.Add("AssignedDate", assignedDate);

                // PROBLEM 3: Hard-coded conditionals based on magic numbers
                if (i == 6) // What business rule does "6" represent?
                {
                    supervisorId = GetDepartmentManager(departmentId);
                    parameters.Add("RoleTypeCode", i);
                    parameters.Add("SupervisorId", supervisorId);

                    Console.WriteLine($"Assigning role type {i} (what role?) to user {userId}");

                    // PROBLEM 4: Database calls scattered throughout loop
                    ExecuteDatabaseCommand("InsertUserRole", parameters);

                    // PROBLEM 5: More magic numbers in related method calls
                    CreateWorkAssignment(supervisorId, 101, userId, 25); // 101? 25?
                }
                else if (i == 7) // What business rule does "7" represent?
                {
                    supervisorId = GetProjectCoordinator(departmentId);
                    parameters.Add("RoleTypeCode", i);
                    parameters.Add("SupervisorId", supervisorId);

                    Console.WriteLine($"Assigning role type {i} (what role?) to user {userId}");
                    ExecuteDatabaseCommand("InsertUserRole", parameters);

                    // PROBLEM 6: Complex conditional logic with more magic numbers
                    var workRoleCode = (IsSpecialDepartment(departmentId) ? 202 : 203);
                    CreateWorkAssignment(supervisorId, workRoleCode, userId, 25);
                }
            }
        }

        private void ExecuteDatabaseCommand(string command, Dictionary<string, object> parameters)
        {
            Console.WriteLine($"  Executing {command} with {parameters.Count} parameters");
        }

        private void CreateWorkAssignment(string supervisorId, int roleCode, string userId, int resourceType)
        {
            Console.WriteLine($"  Creating work assignment: Supervisor={supervisorId}, RoleCode={roleCode}, ResourceType={resourceType}");
        }

        private string GetDepartmentManager(string departmentId) => "manager-" + departmentId;
        private string GetProjectCoordinator(string departmentId) => "coordinator-" + departmentId;
        private bool IsSpecialDepartment(string departmentId) => departmentId.ToUpper() == "SPECIAL-DEPT";
    }
}



================================================================================
FILE: DemonstrationConsole\DemonstrationConsole.csproj
SIZE: 0.42 KB
MODIFIED: 09/18/2025 10:33:39
================================================================================

<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net10.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>

  <ItemGroup>
    <ProjectReference Include="..\AntiPattern\AntiPattern.csproj" />
    <ProjectReference Include="..\ModernApproach\ModernApproach.csproj" />
  </ItemGroup>

</Project>



================================================================================
FILE: DemonstrationConsole\Program.cs
SIZE: 3.25 KB
MODIFIED: 09/18/2025 10:54:59
================================================================================

// ============================================
// DEMONSTRATION
// ============================================

using ModernApproach;

class Program
{
    static void Main(string[] args)
    {
        Console.WriteLine("=== ANTI-PATTERN: Magic Numbers in Loops ===");
        Console.WriteLine("- for (int i = 6; i <= 7; i++) - what do these numbers mean?");
        Console.WriteLine("- Hard-coded conditions based on loop counter values");
        Console.WriteLine("- Business logic buried inside loop iteration");
        Console.WriteLine("- Additional magic numbers scattered throughout (101, 202, 203, 25)");
        Console.WriteLine();

        var badService = new AntiPattern.RoleAssignmentService_BadWay();
        badService.AssignStandardRoles("user123", "IT-DEPT", DateTime.Now);

        Console.WriteLine();
        Console.WriteLine("=== MODERN APPROACH: Type-Safe, Explicit Business Logic ===");
        Console.WriteLine("Benefits of this refactored approach:");
        Console.WriteLine("- Eliminates magic number loop entirely");
        Console.WriteLine("- Strong types prevent parameter mix-ups at compile time");
        Console.WriteLine("- Command objects replace loose parameter dictionaries");
        Console.WriteLine("- Immutable records with clear business meaning");
        Console.WriteLine("- Type-safe comparisons instead of string manipulation");
        Console.WriteLine("- Each role assignment is explicit and testable");
        Console.WriteLine();

        var goodService = new ModernApproach.RoleAssignmentService_GoodWay();
        goodService.AssignStandardRoles(new UserId("user123"), new DepartmentId("IT-DEPT"), DateTime.Now);

        Console.WriteLine();
        Console.WriteLine("1. ELIMINATE MAGIC NUMBER LOOPS");
        Console.WriteLine("   Replace: for (int i = 6; i <= 7; i++)");
        Console.WriteLine("   With: foreach (var role in GetRequiredRoles())");
        Console.WriteLine();
        Console.WriteLine("2. USE DESCRIPTIVE ENUMS");
        Console.WriteLine("   Replace: if (i == 6) // FOAOwner");
        Console.WriteLine("   With: if (role.Type == SolicitationRoleType.FOAOwner)");
        Console.WriteLine();
        Console.WriteLine("3. CREATE STRONGLY-TYPED DOMAIN OBJECTS");
        Console.WriteLine("   Replace: string userId, string departmentId");
        Console.WriteLine("   With: UserId userId, DepartmentId departmentId");
        Console.WriteLine();
        Console.WriteLine("4. USE COMMAND OBJECTS INSTEAD OF DICTIONARIES");
        Console.WriteLine("   Replace: parameters.Add(\"UserId\", userId)");
        Console.WriteLine("   With: new CreateUserRoleCommand(userId, departmentId, ...)");
        Console.WriteLine();
        Console.WriteLine("5. LEVERAGE COMPILE-TIME TYPE SAFETY");
        Console.WriteLine("   Replace: String comparisons and casting");
        Console.WriteLine("   With: Record equality and strong typing");
        Console.WriteLine();
        Console.WriteLine("This pattern applies to your dependency injection work:");
        Console.WriteLine("- Replace ServiceFactory static calls with injected dependencies");
        Console.WriteLine("- Make configuration paths explicit parameters");
        Console.WriteLine("- Use constructor injection instead of hidden factory dependencies");
    }
}


================================================================================
FILE: ModernApproach\ModernApproach.csproj
SIZE: 0.21 KB
MODIFIED: 09/18/2025 10:32:42
================================================================================

<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net10.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>

</Project>



================================================================================
FILE: ModernApproach\RoleAssignmentService_GoodWay.cs
SIZE: 5.37 KB
MODIFIED: 09/18/2025 10:58:02
================================================================================

// ============================================
// MODERN APPROACH: Explicit, Readable Role Assignment
// ============================================

namespace ModernApproach
{
    // Strong types instead of primitive strings/ints
    public record UserId(string Value);
    public record DepartmentId(string Value);
    public record SupervisorId(string Value);
    public record RoleId(Guid Value)
    {
        public static RoleId New() => new(Guid.NewGuid());
    }
    public record AssignmentId(Guid Value)
    {
        public static AssignmentId New() => new(Guid.NewGuid());
    }

    // Clear enums that document business meaning
    public enum StandardRoleType
    {
        DepartmentManager = 6,    // Maintaining original DB values for compatibility
        ProjectCoordinator = 7
    }

    public enum WorkAssignmentRoleCode
    {
        ProjectManager = 101,
        GeneralAdministrator = 203,
        SpecialAdministrator = 202
    }

    public enum ResourceType
    {
        UserAccount = 25
    }

    // Immutable data structure with strong types
    public record RoleAssignment(
        StandardRoleType RoleType,
        SupervisorId SupervisorId,
        WorkAssignmentRoleCode WorkRole,
        string Description
    );

    // Command object for database operations
    public record CreateUserRoleCommand(
        RoleId RoleId,
        AssignmentId AssignmentId,
        UserId UserId,
        DepartmentId DepartmentId,
        DateTime AssignedDate,
        StandardRoleType RoleType,
        SupervisorId SupervisorId
    );

    public class RoleAssignmentService_GoodWay
    {
        private static readonly DepartmentId SpecialDepartmentCode = new("SPECIAL-DEPT");

        public void AssignStandardRoles(UserId userId, DepartmentId departmentId, DateTime assignedDate)
        {
            // Clear intent: we're getting the roles this user should have
            var roleAssignments = GetStandardRoleAssignments(departmentId);

            // Process each role explicitly - no mystery loops
            foreach (var assignment in roleAssignments)
            {
                ProcessSingleRoleAssignment(userId, departmentId, assignedDate, assignment);
            }
        }

        private List<RoleAssignment> GetStandardRoleAssignments(DepartmentId departmentId)
        {
            return new List<RoleAssignment>
            {
                new RoleAssignment(
                    StandardRoleType.DepartmentManager,
                    GetDepartmentManager(departmentId),
                    WorkAssignmentRoleCode.ProjectManager,
                    "Department Manager - oversees department operations"
                ),
                new RoleAssignment(
                    StandardRoleType.ProjectCoordinator,
                    GetProjectCoordinator(departmentId),
                    GetCoordinatorWorkRole(departmentId),
                    "Project Coordinator - manages project workflows"
                )
            };
        }

        private void ProcessSingleRoleAssignment(UserId userId, DepartmentId departmentId,
            DateTime assignedDate, RoleAssignment assignment)
        {
            // Create strongly-typed command object
            var command = new CreateUserRoleCommand(
                RoleId.New(),
                AssignmentId.New(),
                userId,
                departmentId,
                assignedDate,
                assignment.RoleType,
                assignment.SupervisorId
            );

            Console.WriteLine($"Assigning {assignment.RoleType} role to user {userId.Value}");
            Console.WriteLine($"  Description: {assignment.Description}");

            // Pass strongly-typed command instead of dictionary
            ExecuteDatabaseCommand(command);

            CreateWorkAssignment(
                assignment.SupervisorId,
                assignment.WorkRole,
                userId,
                ResourceType.UserAccount
            );
        }

        private WorkAssignmentRoleCode GetCoordinatorWorkRole(DepartmentId departmentId)
        {
            // Business rule is now explicit and documented with type-safe comparison
            return departmentId == SpecialDepartmentCode
                ? WorkAssignmentRoleCode.SpecialAdministrator
                : WorkAssignmentRoleCode.GeneralAdministrator;
        }

        // Type-safe method signatures prevent parameter mix-ups
        private void ExecuteDatabaseCommand(CreateUserRoleCommand command)
        {
            Console.WriteLine($"  Executing InsertUserRole command");
            Console.WriteLine($"    RoleId: {command.RoleId.Value}");
            Console.WriteLine($"    UserId: {command.UserId.Value}");
            Console.WriteLine($"    RoleType: {command.RoleType}");
        }

        private void CreateWorkAssignment(SupervisorId supervisorId, WorkAssignmentRoleCode roleCode,
            UserId userId, ResourceType resourceType)
        {
            Console.WriteLine($"  Creating work assignment: Supervisor={supervisorId.Value}, " +
                            $"Role={roleCode}, ResourceType={resourceType}");
        }

        private SupervisorId GetDepartmentManager(DepartmentId departmentId)
            => new SupervisorId("manager-" + departmentId.Value);

        private SupervisorId GetProjectCoordinator(DepartmentId departmentId)
            => new SupervisorId("coordinator-" + departmentId.Value);
    }
}


================================================================================
FILE: README.md
SIZE: 8.54 KB
MODIFIED: 09/18/2025 10:45:53
================================================================================

# Eliminating Magic Numbers: From Anti-Pattern to Clean Code

## Overview

This repository demonstrates a common but problematic coding pattern known as "magic numbers" and shows how to refactor it into maintainable, self-documenting code. This anti-pattern is frequently found in enterprise codebases and can significantly impact code readability, maintainability, and team productivity.

## The Problem: Magic Numbers in Control Flow

### What Are Magic Numbers?

Magic numbers are numeric literals that appear in code without explanation of their meaning or purpose. They're called "magic" because their significance is hidden from anyone reading the code.

### The Anti-Pattern in Action

Consider this common pattern found in many enterprise applications:

```csharp
for (int i = 6; i <= 7; i++)
{
    if (i == 6)
    {
        // Some business logic for "6"
        DoSomething(i, "SomeValue");
        CallAnotherMethod(101, userId, 25);
    }
    else if (i == 7)  
    {
        // Different business logic for "7"
        DoSomethingElse(i, "AnotherValue");
        CallAnotherMethod(203, userId, 25);
    }
}
```

### Why This Is Problematic

1. **Unclear Intent**: What do the numbers 6 and 7 represent? What business concepts do they model?

2. **Hidden Business Logic**: The loop structure suggests we're iterating over a sequence, but we're actually processing specific, discrete business cases.

3. **Maintenance Nightmare**: Adding a new case requires modifying the loop bounds and adding another conditional branch.

4. **Scattered Magic Numbers**: Additional magic numbers (101, 203, 25) appear throughout the code with no context.

5. **Poor Testability**: It's difficult to test individual business cases when they're buried inside loop iterations.

6. **Misleading Abstractions**: The loop implies a mathematical sequence when the problem is actually about distinct business entities.

## The Solution: Explicit Business Modeling

### Step 1: Replace Magic Numbers with Enums

```csharp
public enum BusinessRoleType
{
    DepartmentManager = 6,    // Preserve original DB values if needed
    ProjectCoordinator = 7
}

public enum WorkAssignmentCode
{
    ProjectManager = 101,
    GeneralAdministrator = 203,
    SpecialAdministrator = 202
}
```

### Step 2: Create Explicit Data Structures

```csharp
public class RoleAssignment
{
    public BusinessRoleType RoleType { get; set; }
    public string SupervisorId { get; set; }
    public WorkAssignmentCode WorkRole { get; set; }
    public string Description { get; set; }
}
```

### Step 3: Replace Loops with Explicit Collections

```csharp
private List<RoleAssignment> GetRequiredRoleAssignments(string departmentId)
{
    return new List<RoleAssignment>
    {
        new RoleAssignment
        {
            RoleType = BusinessRoleType.DepartmentManager,
            SupervisorId = GetDepartmentManager(departmentId),
            WorkRole = WorkAssignmentCode.ProjectManager,
            Description = "Department Manager - oversees operations"
        },
        new RoleAssignment
        {
            RoleType = BusinessRoleType.ProjectCoordinator,
            SupervisorId = GetProjectCoordinator(departmentId),
            WorkRole = GetCoordinatorWorkRole(departmentId),
            Description = "Project Coordinator - manages workflows"
        }
    };
}
```

### Step 4: Process Each Item Explicitly

```csharp
public void AssignStandardRoles(string userId, string departmentId, DateTime assignedDate)
{
    var roleAssignments = GetRequiredRoleAssignments(departmentId);

    foreach (var assignment in roleAssignments)
    {
        ProcessSingleRoleAssignment(userId, departmentId, assignedDate, assignment);
    }
}
```

## Running the Example

```bash
dotnet run
```

The program will demonstrate both approaches side-by-side, showing the difference in clarity and maintainability.

## Key Benefits of the Refactored Approach

### 1. Self-Documenting Code
- Enum names immediately convey business meaning
- No need to look up what numbers represent
- Code reads like business requirements

### 2. Improved Maintainability
- Adding new roles requires adding to the enum and collection
- No complex loop modifications
- Changes are localized and predictable

### 3. Better Testability
- Each role assignment can be tested independently
- Business logic is separated from iteration logic
- Mock data is easier to create and understand

### 4. Type Safety
- Compiler catches incorrect enum usage
- IntelliSense provides meaningful options
- Refactoring tools work more effectively

### 5. Clear Separation of Concerns
- Data structure definition is separate from processing logic
- Business rules are explicit and centralized
- Database operations are isolated from business logic

## Common Variations of This Anti-Pattern

### Switch Statements on Magic Numbers
```csharp
// Anti-pattern
switch (statusCode)
{
    case 1: // What does 1 mean?
        HandleApproved();
        break;
    case 2: // What does 2 mean?
        HandleRejected();
        break;
}

// Better approach
switch (status)
{
    case ApprovalStatus.Approved:
        HandleApproved();
        break;
    case ApprovalStatus.Rejected:
        HandleRejected();
        break;
}
```

### Configuration-Based Magic Numbers
```csharp
// Anti-pattern
if (userType == 3 && accessLevel >= 5)
{
    // Business logic here
}

// Better approach  
if (user.Type == UserType.Administrator && 
    user.AccessLevel >= AccessLevel.FullAccess)
{
    // Business logic here
}
```

## When to Apply This Refactoring

### Red Flags to Watch For
- Loops that iterate over a small, fixed range of numbers
- Multiple `if` statements checking specific numeric values
- Comments that explain what numbers represent
- Database queries with hard-coded numeric parameters
- Complex conditional logic based on numeric ranges

### Safe Refactoring Steps
1. **Identify the business concepts** behind the magic numbers
2. **Create enums** with descriptive names
3. **Extract data structures** that model the business domain
4. **Replace loops** with explicit collections or method calls
5. **Move complex logic** into separate, well-named methods
6. **Add unit tests** for each business scenario

## Legacy System Considerations

### Maintaining Database Compatibility
When refactoring legacy systems, you may need to preserve the original numeric values:

```csharp
public enum LegacyStatusCode
{
    [Description("Pending Review")]
    PendingReview = 1,
    
    [Description("Under Investigation")]  
    UnderInvestigation = 3,
    
    [Description("Approved")]
    Approved = 7  // Skip 2,4,5,6 for historical reasons
}
```

### Gradual Migration Strategy
1. Create enums alongside existing magic numbers
2. Add conversion methods between old and new representations
3. Update one module at a time
4. Maintain backward compatibility during transition
5. Remove magic numbers once all dependent code is updated

## Best Practices Summary

### Do
- Use descriptive enum names that reflect business concepts
- Group related constants into cohesive enums
- Add XML documentation to explain business rules
- Create explicit data structures for complex business entities
- Write unit tests for each business scenario

### Don't
- Use magic numbers for business logic decisions
- Create loops that iterate over business concepts
- Bury business rules inside control flow structures
- Mix data representation with processing logic
- Assume numeric sequences represent business relationships

## Further Reading

- [Clean Code: A Handbook of Agile Software Craftsmanship](https://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882)
- [Refactoring: Improving the Design of Existing Code](https://martinfowler.com/books/refactoring.html)
- [Code Complete: A Practical Handbook of Software Construction](https://www.amazon.com/Code-Complete-Practical-Handbook-Construction/dp/0735619670)

## Contributing

When contributing to this example, please:
1. Keep examples generic and applicable to any domain
2. Focus on fundamental programming principles
3. Provide clear before/after comparisons
4. Include unit tests for any new examples
5. Update documentation to reflect changes

## License

This educational example is provided under the AGPLv3 License.

âš ï¸ AI Disclosure: 
This project includes code generated with assistance from Large Language Models (LLMs) including Claude. 
Use at your own discretion.



===============================================================================
EXPORT COMPLETED: 09/18/2025 11:09:41
Total Files Exported: 7
Output File: C:\Users\kushal\source\repos\AvoidMagicNumbers\llm\dump.txt
===============================================================================
