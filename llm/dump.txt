
===============================================================================
ASP.NET PROJECT EXPORT
Generated: 09/18/2025 16:18:51
Project Path: C:\Users\kushal\source\repos\AvoidMagicNumbers
===============================================================================

DIRECTORY STRUCTURE:
===================

Folder PATH listing
Volume serial number is 9892-5BAD
C:\USERS\KUSHAL\SOURCE\REPOS\AVOIDMAGICNUMBERS
|   .gitattributes
|   .gitignore
|   AvoidMagicNumbers.slnx
|   Export-Project.ps1
|   README.md
|   
+---.github
|   \---workflows
|           build-and-test.yml
|           
+---AntiPattern
|       AntiPattern.csproj
|       RoleAssignmentService_BadWay.cs
|       
+---DemonstrationConsole
|       DemonstrationConsole.csproj
|       Program.cs
|       
+---llm
|       dump.txt
|       
\---ModernApproach
        ModernApproach.csproj
        RoleAssignmentService_GoodWay.cs
        


FILE CONTENTS:
==============

================================================================================
FILE: .github\workflows\build-and-test.yml
SIZE: 1.8 KB
MODIFIED: 09/18/2025 13:48:29
================================================================================

name: Build and Test

on:
  push:
    branches: [ master, main, develop ]
  pull_request:
    branches: [ main, master ]

jobs:
  build-and-test:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v5
    
    - name: Setup .NET
      uses: actions/setup-dotnet@v5
      with:
        dotnet-version: '10.0.x'
        include-prerelease: true
    
    - name: Restore dependencies
      run: dotnet restore
    
    - name: Build
      run: dotnet build --no-restore --configuration Release
    
    - name: Run demonstration
      run: |
        echo "Running magic numbers demonstration..."
        dotnet run --project DemonstrationConsole --configuration Release --no-build
        echo "Demo completed successfully!"
    
    - name: Verify build artifacts
      run: |
        echo "Checking build outputs..."
        ls -la */bin/Release/net10.0/
        echo "All artifacts present!"

  build-matrix:
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
        dotnet-version: ['10.0.x']
    
    runs-on: ${{ matrix.os }}
    
    steps:
    - uses: actions/checkout@v5
    
    - name: Setup .NET ${{ matrix.dotnet-version }}
      uses: actions/setup-dotnet@v5
      with:
        dotnet-version: ${{ matrix.dotnet-version }}
        include-prerelease: true
    
    - name: Restore dependencies
      run: dotnet restore
    
    - name: Build
      run: dotnet build --no-restore --configuration Release
    
    - name: Run demo on ${{ matrix.os }}
      run: dotnet run --project DemonstrationConsole --configuration Release --no-build
    
    - name: Test clean build
      run: |
        dotnet clean
        dotnet build --configuration Release
        echo "Clean build successful on ${{ matrix.os }}"



================================================================================
FILE: AntiPattern\AntiPattern.csproj
SIZE: 0.21 KB
MODIFIED: 09/18/2025 10:31:58
================================================================================

<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net10.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>

</Project>



================================================================================
FILE: AntiPattern\RoleAssignmentService_BadWay.cs
SIZE: 3.38 KB
MODIFIED: 09/18/2025 10:55:43
================================================================================

// ============================================
// ANTI-PATTERN: Using Magic Numbers in Loops
// ============================================

namespace AntiPattern
{
    public class RoleAssignmentService_BadWay
    {
        private Dictionary<string, object> parameters = new Dictionary<string, object>();

        public void AssignStandardRoles(string userId, string departmentId, DateTime assignedDate)
        {
            // PROBLEM 1: Magic numbers in loop - what do 6 and 7 represent?
            for (int i = 6; i <= 7; i++)
            {
                string roleId = Guid.NewGuid().ToString();
                string assignmentId = Guid.NewGuid().ToString();
                string supervisorId = null;

                // PROBLEM 2: Building parameters inside loop with unclear logic
                parameters.Clear();
                parameters.Add("RoleId", roleId);
                parameters.Add("AssignmentId", assignmentId);
                parameters.Add("UserId", userId);
                parameters.Add("DepartmentId", departmentId);
                parameters.Add("AssignedDate", assignedDate);

                // PROBLEM 3: Hard-coded conditionals based on magic numbers
                if (i == 6) // What business rule does "6" represent?
                {
                    supervisorId = GetDepartmentManager(departmentId);
                    parameters.Add("RoleTypeCode", i);
                    parameters.Add("SupervisorId", supervisorId);

                    Console.WriteLine($"Assigning role type {i} (what role?) to user {userId}");

                    // PROBLEM 4: Database calls scattered throughout loop
                    ExecuteDatabaseCommand("InsertUserRole", parameters);

                    // PROBLEM 5: More magic numbers in related method calls
                    CreateWorkAssignment(supervisorId, 101, userId, 25); // 101? 25?
                }
                else if (i == 7) // What business rule does "7" represent?
                {
                    supervisorId = GetProjectCoordinator(departmentId);
                    parameters.Add("RoleTypeCode", i);
                    parameters.Add("SupervisorId", supervisorId);

                    Console.WriteLine($"Assigning role type {i} (what role?) to user {userId}");
                    ExecuteDatabaseCommand("InsertUserRole", parameters);

                    // PROBLEM 6: Complex conditional logic with more magic numbers
                    var workRoleCode = (IsSpecialDepartment(departmentId) ? 202 : 203);
                    CreateWorkAssignment(supervisorId, workRoleCode, userId, 25);
                }
            }
        }

        private void ExecuteDatabaseCommand(string command, Dictionary<string, object> parameters)
        {
            Console.WriteLine($"  Executing {command} with {parameters.Count} parameters");
        }

        private void CreateWorkAssignment(string supervisorId, int roleCode, string userId, int resourceType)
        {
            Console.WriteLine($"  Creating work assignment: Supervisor={supervisorId}, RoleCode={roleCode}, ResourceType={resourceType}");
        }

        private string GetDepartmentManager(string departmentId) => "manager-" + departmentId;
        private string GetProjectCoordinator(string departmentId) => "coordinator-" + departmentId;
        private bool IsSpecialDepartment(string departmentId) => departmentId.ToUpper() == "SPECIAL-DEPT";
    }
}



================================================================================
FILE: AvoidMagicNumbers.slnx
SIZE: 0.2 KB
MODIFIED: 09/18/2025 10:33:39
================================================================================

<Solution>
  <Project Path="AntiPattern/AntiPattern.csproj" />
  <Project Path="DemonstrationConsole/DemonstrationConsole.csproj" />
  <Project Path="ModernApproach/ModernApproach.csproj" />
</Solution>



================================================================================
FILE: DemonstrationConsole\DemonstrationConsole.csproj
SIZE: 0.42 KB
MODIFIED: 09/18/2025 10:33:39
================================================================================

<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net10.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>

  <ItemGroup>
    <ProjectReference Include="..\AntiPattern\AntiPattern.csproj" />
    <ProjectReference Include="..\ModernApproach\ModernApproach.csproj" />
  </ItemGroup>

</Project>



================================================================================
FILE: DemonstrationConsole\Program.cs
SIZE: 3.25 KB
MODIFIED: 09/18/2025 15:47:12
================================================================================

// ============================================
// DEMONSTRATION
// ============================================

using ModernApproach;

class Program
{
    static void Main(string[] args)
    {
        Console.WriteLine("=== ANTI-PATTERN: Magic Numbers in Loops ===");
        Console.WriteLine("- for (int i = 6; i <= 7; i++) - what do these numbers mean?");
        Console.WriteLine("- Hard-coded conditions based on loop counter values");
        Console.WriteLine("- Business logic buried inside loop iteration");
        Console.WriteLine("- Additional magic numbers scattered throughout (101, 202, 203, 25)");
        Console.WriteLine();

        var badService = new AntiPattern.RoleAssignmentService_BadWay();
        badService.AssignStandardRoles("user123", "IT-DEPT", DateTime.Now);

        Console.WriteLine();
        Console.WriteLine("=== MODERN APPROACH: Type-Safe, Explicit Business Logic ===");
        Console.WriteLine("Benefits of this refactored approach:");
        Console.WriteLine("- Eliminates magic number loop entirely");
        Console.WriteLine("- Strong types prevent parameter mix-ups at compile time");
        Console.WriteLine("- Command objects replace loose parameter dictionaries");
        Console.WriteLine("- Immutable records with clear business meaning");
        Console.WriteLine("- Type-safe comparisons instead of string manipulation");
        Console.WriteLine("- Each role assignment is explicit and testable");
        Console.WriteLine();

        var goodService = ModernApproach.DemoRoleAssignmentService.Create();
        goodService.AssignStandardRoles(new UserId("user123"), new DepartmentId("IT-DEPT"), DateTime.Now);

        Console.WriteLine();
        Console.WriteLine("1. ELIMINATE MAGIC NUMBER LOOPS");
        Console.WriteLine("   Replace: for (int i = 6; i <= 7; i++)");
        Console.WriteLine("   With: foreach (var role in GetRequiredRoles())");
        Console.WriteLine();
        Console.WriteLine("2. USE DESCRIPTIVE ENUMS");
        Console.WriteLine("   Replace: if (i == 6) // FOAOwner");
        Console.WriteLine("   With: if (role.Type == SolicitationRoleType.FOAOwner)");
        Console.WriteLine();
        Console.WriteLine("3. CREATE STRONGLY-TYPED DOMAIN OBJECTS");
        Console.WriteLine("   Replace: string userId, string departmentId");
        Console.WriteLine("   With: UserId userId, DepartmentId departmentId");
        Console.WriteLine();
        Console.WriteLine("4. USE COMMAND OBJECTS INSTEAD OF DICTIONARIES");
        Console.WriteLine("   Replace: parameters.Add(\"UserId\", userId)");
        Console.WriteLine("   With: new CreateUserRoleCommand(userId, departmentId, ...)");
        Console.WriteLine();
        Console.WriteLine("5. LEVERAGE COMPILE-TIME TYPE SAFETY");
        Console.WriteLine("   Replace: String comparisons and casting");
        Console.WriteLine("   With: Record equality and strong typing");
        Console.WriteLine();
        Console.WriteLine("This pattern applies to your dependency injection work:");
        Console.WriteLine("- Replace ServiceFactory static calls with injected dependencies");
        Console.WriteLine("- Make configuration paths explicit parameters");
        Console.WriteLine("- Use constructor injection instead of hidden factory dependencies");
    }
}



================================================================================
FILE: ModernApproach\ModernApproach.csproj
SIZE: 0.21 KB
MODIFIED: 09/18/2025 10:32:42
================================================================================

<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net10.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>

</Project>



================================================================================
FILE: ModernApproach\RoleAssignmentService_GoodWay.cs
SIZE: 17.85 KB
MODIFIED: 09/18/2025 16:18:28
================================================================================

// ============================================
// MODERN APPROACH: Explicit, Readable Role Assignment with Practical DI
// ============================================

using System.ComponentModel;

namespace ModernApproach
{
    // ============================================
    // STRONG TYPES - Prevent primitive obsession
    // ============================================
    
    public readonly record struct UserId(string Value)
    {
        public static implicit operator string(UserId userId) => userId.Value;
        public override string ToString() => Value;
        
        public static UserId From(string value) => 
            string.IsNullOrWhiteSpace(value) 
                ? throw new ArgumentException("UserId cannot be null or empty", nameof(value))
                : new(value);
    }
    
    public readonly record struct DepartmentId(string Value) : IEquatable<DepartmentId>
    {
        public static implicit operator string(DepartmentId departmentId) => departmentId.Value;
        public override string ToString() => Value;
        
        public static DepartmentId From(string value) => 
            string.IsNullOrWhiteSpace(value) 
                ? throw new ArgumentException("DepartmentId cannot be null or empty", nameof(value))
                : new(value);
        
        public bool Equals(DepartmentId other) =>
            string.Equals(Value, other.Value, StringComparison.OrdinalIgnoreCase);
        
        public override int GetHashCode() => 
            StringComparer.OrdinalIgnoreCase.GetHashCode(Value);
    }
    
    public readonly record struct SupervisorId(string Value)
    {
        public static implicit operator string(SupervisorId supervisorId) => supervisorId.Value;
        public override string ToString() => Value;
    }
    
    public readonly record struct RoleId(Guid Value)
    {
        public static RoleId New() => new(Guid.NewGuid());
        public static implicit operator Guid(RoleId roleId) => roleId.Value;
        public override string ToString() => Value.ToString();
    }

    // ============================================
    // ENUMS - Document business meaning
    // ============================================
    
    public enum StandardRoleType
    {
        [Description("Department Manager - oversees department operations")]
        DepartmentManager = 6,
        
        [Description("Project Coordinator - manages project workflows")]
        ProjectCoordinator = 7
    }

    public enum WorkAssignmentRoleCode
    {
        ProjectManager = 101,
        GeneralAdministrator = 203,
        SpecialAdministrator = 202
    }

    public enum ResourceType
    {
        UserAccount = 25
    }

    // ============================================
    // RESULT TYPES - Simplified error handling
    // ============================================
    
    public sealed record RoleAssignmentResult
    {
        public IReadOnlyList<RoleAssignmentSuccess> Successes { get; init; } = [];
        public IReadOnlyList<RoleAssignmentFailure> Failures { get; init; } = [];
        
        public bool IsSuccess => Failures.Count == 0 && Successes.Count > 0;
        public bool HasFailures => Failures.Count > 0;
        
        public static RoleAssignmentResult Success(params RoleAssignmentSuccess[] successes) => 
            new() { Successes = successes };
        
        public static RoleAssignmentResult WithFailures(params RoleAssignmentFailure[] failures) => 
            new() { Failures = failures };
        
        public static RoleAssignmentResult Mixed(
            IEnumerable<RoleAssignmentSuccess> successes, 
            IEnumerable<RoleAssignmentFailure> failures) => 
            new() { 
                Successes = successes.ToArray(),
                Failures = failures.ToArray()
            };
    }

    public sealed record RoleAssignmentSuccess(RoleId RoleId, StandardRoleType RoleType, string Description);
    public sealed record RoleAssignmentFailure(StandardRoleType RoleType, string Error);

    // ============================================
    // DATA STRUCTURES - Immutable domain models
    // ============================================
    
    public sealed record RoleAssignment(
        StandardRoleType RoleType,
        SupervisorId SupervisorId,
        WorkAssignmentRoleCode WorkRole
    )
    {
        public string Description => RoleType.GetDescription();
    }

    public sealed record CreateUserRoleCommand(
        RoleId RoleId,
        UserId UserId,
        DepartmentId DepartmentId,
        DateTime AssignedDate,
        StandardRoleType RoleType,
        SupervisorId SupervisorId
    );

    public sealed record WorkAssignmentCommand(
        SupervisorId SupervisorId,
        WorkAssignmentRoleCode RoleCode,
        UserId UserId,
        ResourceType ResourceType,
        DateTime CreatedDate
    );

    // ============================================
    // CONFIGURATION - Externalized settings
    // ============================================
    
    public sealed record RoleAssignmentOptions
    {
        public static readonly RoleAssignmentOptions Default = new();
        
        public IReadOnlySet<DepartmentId> SpecialDepartments { get; init; } = 
            new HashSet<DepartmentId> { DepartmentId.From("SPECIAL-DEPT") };
        
        public bool ValidateExistingRoles { get; init; } = true;
        public bool AllowPartialFailures { get; init; } = true;
        public TimeSpan TransactionTimeout { get; init; } = TimeSpan.FromMinutes(5);
    }

    // ============================================
    // INTERFACES - Dependency abstractions
    // ============================================
    
    public interface IUserRoleRepository
    {
        Task CreateUserRoleAsync(CreateUserRoleCommand command, CancellationToken cancellationToken = default);
        Task<IReadOnlySet<StandardRoleType>> GetExistingRoleTypesAsync(UserId userId, CancellationToken cancellationToken = default);
    }

    public interface IWorkAssignmentRepository
    {
        Task CreateWorkAssignmentAsync(WorkAssignmentCommand command, CancellationToken cancellationToken = default);
    }

    public interface ISupervisorResolver
    {
        SupervisorId GetDepartmentManager(DepartmentId departmentId);
        SupervisorId GetProjectCoordinator(DepartmentId departmentId);
    }

    public interface IRoleAssignmentLogger
    {
        void LogRoleAssignmentStarting(UserId userId, DepartmentId departmentId, int roleCount);
        void LogRoleAssignmentCompleted(UserId userId, int successCount, int failureCount);
        void LogRoleAssigning(StandardRoleType roleType, UserId userId);
        void LogRoleAssigned(RoleId roleId, StandardRoleType roleType, UserId userId);
        void LogRoleAssignmentFailed(StandardRoleType roleType, UserId userId, string error);
        void LogWorkAssignmentCreated(SupervisorId supervisorId, WorkAssignmentRoleCode roleCode);
    }

    // ============================================
    // EXTENSION METHODS - Clean code helpers
    // ============================================
    
    public static class EnumExtensions
    {
        public static string GetDescription(this Enum value)
        {
            var field = value.GetType().GetField(value.ToString());
            var attribute = field?.GetCustomAttributes(typeof(DescriptionAttribute), false)
                               .Cast<DescriptionAttribute>()
                               .FirstOrDefault();
            return attribute?.Description ?? value.ToString();
        }
    }

    public static class RoleAssignmentExtensions
    {
        private const string ManagerPrefix = "manager-";
        private const string CoordinatorPrefix = "coordinator-";
        
        public static SupervisorId GetDepartmentManager(this DepartmentId departmentId) =>
            new($"{ManagerPrefix}{departmentId.Value}");
        
        public static SupervisorId GetProjectCoordinator(this DepartmentId departmentId) =>
            new($"{CoordinatorPrefix}{departmentId.Value}");
    }

    // ============================================
    // SERVICE - Main business logic with practical DI
    // ============================================
    
    public sealed class RoleAssignmentService_GoodWay
    {
        private readonly IUserRoleRepository _userRoleRepository;
        private readonly IWorkAssignmentRepository _workAssignmentRepository;
        private readonly ISupervisorResolver _supervisorResolver;
        private readonly IRoleAssignmentLogger _logger;
        private readonly RoleAssignmentOptions _options;

        public RoleAssignmentService_GoodWay(
            IUserRoleRepository userRoleRepository,
            IWorkAssignmentRepository workAssignmentRepository,
            ISupervisorResolver supervisorResolver,
            IRoleAssignmentLogger logger,
            RoleAssignmentOptions? options = null)
        {
            _userRoleRepository = userRoleRepository ?? throw new ArgumentNullException(nameof(userRoleRepository));
            _workAssignmentRepository = workAssignmentRepository ?? throw new ArgumentNullException(nameof(workAssignmentRepository));
            _supervisorResolver = supervisorResolver ?? throw new ArgumentNullException(nameof(supervisorResolver));
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
            _options = options ?? RoleAssignmentOptions.Default;
        }

        public async Task<RoleAssignmentResult> AssignStandardRolesAsync(
            UserId userId, 
            DepartmentId departmentId, 
            DateTime assignedDate,
            CancellationToken cancellationToken = default)
        {
            var roleAssignments = CreateStandardRoleAssignments(departmentId);
            _logger.LogRoleAssignmentStarting(userId, departmentId, roleAssignments.Count);

            var existingRoles = _options.ValidateExistingRoles
                ? await _userRoleRepository.GetExistingRoleTypesAsync(userId, cancellationToken)
                : new HashSet<StandardRoleType>();

            var successes = new List<RoleAssignmentSuccess>();
            var failures = new List<RoleAssignmentFailure>();

            foreach (var assignment in roleAssignments)
            {
                if (existingRoles.Contains(assignment.RoleType))
                {
                    var error = $"User already has {assignment.RoleType.GetDescription()} role";
                    _logger.LogRoleAssignmentFailed(assignment.RoleType, userId, error);
                    failures.Add(new RoleAssignmentFailure(assignment.RoleType, error));
                    continue;
                }

                try
                {
                    var roleId = await ProcessRoleAssignmentAsync(userId, departmentId, assignedDate, assignment, cancellationToken);
                    successes.Add(new RoleAssignmentSuccess(roleId, assignment.RoleType, assignment.Description));
                }
                catch (Exception ex)
                {
                    _logger.LogRoleAssignmentFailed(assignment.RoleType, userId, ex.Message);
                    failures.Add(new RoleAssignmentFailure(assignment.RoleType, ex.Message));
                    
                    if (!_options.AllowPartialFailures)
                        break;
                }
            }

            _logger.LogRoleAssignmentCompleted(userId, successes.Count, failures.Count);
            return RoleAssignmentResult.Mixed(successes, failures);
        }

        // Synchronous convenience method
        public void AssignStandardRoles(UserId userId, DepartmentId departmentId, DateTime assignedDate)
        {
            var result = AssignStandardRolesAsync(userId, departmentId, assignedDate).GetAwaiter().GetResult();
            if (!result.IsSuccess && result.Failures.Any())
            {
                var errors = string.Join(", ", result.Failures.Select(f => f.Error));
                throw new InvalidOperationException($"Role assignment failed: {errors}");
            }
        }

        private IReadOnlyList<RoleAssignment> CreateStandardRoleAssignments(DepartmentId departmentId)
        {
            return
            [
                new RoleAssignment(
                    StandardRoleType.DepartmentManager,
                    _supervisorResolver.GetDepartmentManager(departmentId),
                    WorkAssignmentRoleCode.ProjectManager),
                
                new RoleAssignment(
                    StandardRoleType.ProjectCoordinator,
                    _supervisorResolver.GetProjectCoordinator(departmentId),
                    GetCoordinatorWorkRole(departmentId))
            ];
        }

        private WorkAssignmentRoleCode GetCoordinatorWorkRole(DepartmentId departmentId) =>
            _options.SpecialDepartments.Contains(departmentId)
                ? WorkAssignmentRoleCode.SpecialAdministrator
                : WorkAssignmentRoleCode.GeneralAdministrator;

        private async Task<RoleId> ProcessRoleAssignmentAsync(
            UserId userId, 
            DepartmentId departmentId,
            DateTime assignedDate, 
            RoleAssignment assignment,
            CancellationToken cancellationToken)
        {
            var roleId = RoleId.New();
            
            _logger.LogRoleAssigning(assignment.RoleType, userId);
            
            var userRoleCommand = new CreateUserRoleCommand(
                roleId, userId, departmentId, assignedDate, assignment.RoleType, assignment.SupervisorId);
            
            await _userRoleRepository.CreateUserRoleAsync(userRoleCommand, cancellationToken);
            
            var workCommand = new WorkAssignmentCommand(
                assignment.SupervisorId, assignment.WorkRole, userId, ResourceType.UserAccount, assignedDate);
            
            await _workAssignmentRepository.CreateWorkAssignmentAsync(workCommand, cancellationToken);
            
            _logger.LogRoleAssigned(roleId, assignment.RoleType, userId);
            _logger.LogWorkAssignmentCreated(assignment.SupervisorId, assignment.WorkRole);
            
            return roleId;
        }
    }

    // ============================================
    // DEFAULT IMPLEMENTATIONS - For demo/testing
    // ============================================
    
    public sealed class ConsoleRoleAssignmentLogger : IRoleAssignmentLogger
    {
        public void LogRoleAssignmentStarting(UserId userId, DepartmentId departmentId, int roleCount)
        {
            Console.WriteLine($"[INFO] Starting assignment of {roleCount} roles for user {userId} in department {departmentId}");
        }

        public void LogRoleAssignmentCompleted(UserId userId, int successCount, int failureCount)
        {
            Console.WriteLine($"[INFO] Completed role assignment for user {userId} - Success: {successCount}, Failed: {failureCount}");
        }

        public void LogRoleAssigning(StandardRoleType roleType, UserId userId)
        {
            Console.WriteLine($"[INFO] Assigning {roleType.GetDescription()} to user {userId}");
        }

        public void LogRoleAssigned(RoleId roleId, StandardRoleType roleType, UserId userId)
        {
            Console.WriteLine($"[DEBUG] Successfully created role assignment {roleId} ({roleType}) for user {userId}");
        }

        public void LogRoleAssignmentFailed(StandardRoleType roleType, UserId userId, string error)
        {
            Console.WriteLine($"[WARN] Failed to assign {roleType} to user {userId}: {error}");
        }

        public void LogWorkAssignmentCreated(SupervisorId supervisorId, WorkAssignmentRoleCode roleCode)
        {
            Console.WriteLine($"[REPO] Created work assignment - Supervisor: {supervisorId}, Role: {roleCode}");
        }
    }

    public sealed class DemoUserRoleRepository : IUserRoleRepository
    {
        public Task CreateUserRoleAsync(CreateUserRoleCommand command, CancellationToken cancellationToken = default)
        {
            Console.WriteLine($"[REPO] Creating user role - RoleId: {command.RoleId}, UserId: {command.UserId}");
            return Task.CompletedTask;
        }

        public Task<IReadOnlySet<StandardRoleType>> GetExistingRoleTypesAsync(UserId userId, CancellationToken cancellationToken = default)
        {
            return Task.FromResult<IReadOnlySet<StandardRoleType>>(new HashSet<StandardRoleType>());
        }
    }

    public sealed class DemoWorkAssignmentRepository : IWorkAssignmentRepository
    {
        public Task CreateWorkAssignmentAsync(WorkAssignmentCommand command, CancellationToken cancellationToken = default)
        {
            // Logging handled by the logger, not the repository
            return Task.CompletedTask;
        }
    }

    public sealed class DefaultSupervisorResolver : ISupervisorResolver
    {
        public SupervisorId GetDepartmentManager(DepartmentId departmentId) =>
            departmentId.GetDepartmentManager();

        public SupervisorId GetProjectCoordinator(DepartmentId departmentId) =>
            departmentId.GetProjectCoordinator();
    }

    // ============================================
    // DEMO FACTORY - Simplified creation
    // ============================================
    
    public static class DemoRoleAssignmentService
    {
        public static RoleAssignmentService_GoodWay Create()
        {
            return new RoleAssignmentService_GoodWay(
                new DemoUserRoleRepository(),
                new DemoWorkAssignmentRepository(),
                new DefaultSupervisorResolver(),
                new ConsoleRoleAssignmentLogger(),
                RoleAssignmentOptions.Default
            );
        }
    }
}



================================================================================
FILE: README.md
SIZE: 8.54 KB
MODIFIED: 09/18/2025 10:45:53
================================================================================

# Eliminating Magic Numbers: From Anti-Pattern to Clean Code

## Overview

This repository demonstrates a common but problematic coding pattern known as "magic numbers" and shows how to refactor it into maintainable, self-documenting code. This anti-pattern is frequently found in enterprise codebases and can significantly impact code readability, maintainability, and team productivity.

## The Problem: Magic Numbers in Control Flow

### What Are Magic Numbers?

Magic numbers are numeric literals that appear in code without explanation of their meaning or purpose. They're called "magic" because their significance is hidden from anyone reading the code.

### The Anti-Pattern in Action

Consider this common pattern found in many enterprise applications:

```csharp
for (int i = 6; i <= 7; i++)
{
    if (i == 6)
    {
        // Some business logic for "6"
        DoSomething(i, "SomeValue");
        CallAnotherMethod(101, userId, 25);
    }
    else if (i == 7)  
    {
        // Different business logic for "7"
        DoSomethingElse(i, "AnotherValue");
        CallAnotherMethod(203, userId, 25);
    }
}
```

### Why This Is Problematic

1. **Unclear Intent**: What do the numbers 6 and 7 represent? What business concepts do they model?

2. **Hidden Business Logic**: The loop structure suggests we're iterating over a sequence, but we're actually processing specific, discrete business cases.

3. **Maintenance Nightmare**: Adding a new case requires modifying the loop bounds and adding another conditional branch.

4. **Scattered Magic Numbers**: Additional magic numbers (101, 203, 25) appear throughout the code with no context.

5. **Poor Testability**: It's difficult to test individual business cases when they're buried inside loop iterations.

6. **Misleading Abstractions**: The loop implies a mathematical sequence when the problem is actually about distinct business entities.

## The Solution: Explicit Business Modeling

### Step 1: Replace Magic Numbers with Enums

```csharp
public enum BusinessRoleType
{
    DepartmentManager = 6,    // Preserve original DB values if needed
    ProjectCoordinator = 7
}

public enum WorkAssignmentCode
{
    ProjectManager = 101,
    GeneralAdministrator = 203,
    SpecialAdministrator = 202
}
```

### Step 2: Create Explicit Data Structures

```csharp
public class RoleAssignment
{
    public BusinessRoleType RoleType { get; set; }
    public string SupervisorId { get; set; }
    public WorkAssignmentCode WorkRole { get; set; }
    public string Description { get; set; }
}
```

### Step 3: Replace Loops with Explicit Collections

```csharp
private List<RoleAssignment> GetRequiredRoleAssignments(string departmentId)
{
    return new List<RoleAssignment>
    {
        new RoleAssignment
        {
            RoleType = BusinessRoleType.DepartmentManager,
            SupervisorId = GetDepartmentManager(departmentId),
            WorkRole = WorkAssignmentCode.ProjectManager,
            Description = "Department Manager - oversees operations"
        },
        new RoleAssignment
        {
            RoleType = BusinessRoleType.ProjectCoordinator,
            SupervisorId = GetProjectCoordinator(departmentId),
            WorkRole = GetCoordinatorWorkRole(departmentId),
            Description = "Project Coordinator - manages workflows"
        }
    };
}
```

### Step 4: Process Each Item Explicitly

```csharp
public void AssignStandardRoles(string userId, string departmentId, DateTime assignedDate)
{
    var roleAssignments = GetRequiredRoleAssignments(departmentId);

    foreach (var assignment in roleAssignments)
    {
        ProcessSingleRoleAssignment(userId, departmentId, assignedDate, assignment);
    }
}
```

## Running the Example

```bash
dotnet run
```

The program will demonstrate both approaches side-by-side, showing the difference in clarity and maintainability.

## Key Benefits of the Refactored Approach

### 1. Self-Documenting Code
- Enum names immediately convey business meaning
- No need to look up what numbers represent
- Code reads like business requirements

### 2. Improved Maintainability
- Adding new roles requires adding to the enum and collection
- No complex loop modifications
- Changes are localized and predictable

### 3. Better Testability
- Each role assignment can be tested independently
- Business logic is separated from iteration logic
- Mock data is easier to create and understand

### 4. Type Safety
- Compiler catches incorrect enum usage
- IntelliSense provides meaningful options
- Refactoring tools work more effectively

### 5. Clear Separation of Concerns
- Data structure definition is separate from processing logic
- Business rules are explicit and centralized
- Database operations are isolated from business logic

## Common Variations of This Anti-Pattern

### Switch Statements on Magic Numbers
```csharp
// Anti-pattern
switch (statusCode)
{
    case 1: // What does 1 mean?
        HandleApproved();
        break;
    case 2: // What does 2 mean?
        HandleRejected();
        break;
}

// Better approach
switch (status)
{
    case ApprovalStatus.Approved:
        HandleApproved();
        break;
    case ApprovalStatus.Rejected:
        HandleRejected();
        break;
}
```

### Configuration-Based Magic Numbers
```csharp
// Anti-pattern
if (userType == 3 && accessLevel >= 5)
{
    // Business logic here
}

// Better approach  
if (user.Type == UserType.Administrator && 
    user.AccessLevel >= AccessLevel.FullAccess)
{
    // Business logic here
}
```

## When to Apply This Refactoring

### Red Flags to Watch For
- Loops that iterate over a small, fixed range of numbers
- Multiple `if` statements checking specific numeric values
- Comments that explain what numbers represent
- Database queries with hard-coded numeric parameters
- Complex conditional logic based on numeric ranges

### Safe Refactoring Steps
1. **Identify the business concepts** behind the magic numbers
2. **Create enums** with descriptive names
3. **Extract data structures** that model the business domain
4. **Replace loops** with explicit collections or method calls
5. **Move complex logic** into separate, well-named methods
6. **Add unit tests** for each business scenario

## Legacy System Considerations

### Maintaining Database Compatibility
When refactoring legacy systems, you may need to preserve the original numeric values:

```csharp
public enum LegacyStatusCode
{
    [Description("Pending Review")]
    PendingReview = 1,
    
    [Description("Under Investigation")]  
    UnderInvestigation = 3,
    
    [Description("Approved")]
    Approved = 7  // Skip 2,4,5,6 for historical reasons
}
```

### Gradual Migration Strategy
1. Create enums alongside existing magic numbers
2. Add conversion methods between old and new representations
3. Update one module at a time
4. Maintain backward compatibility during transition
5. Remove magic numbers once all dependent code is updated

## Best Practices Summary

### Do
- Use descriptive enum names that reflect business concepts
- Group related constants into cohesive enums
- Add XML documentation to explain business rules
- Create explicit data structures for complex business entities
- Write unit tests for each business scenario

### Don't
- Use magic numbers for business logic decisions
- Create loops that iterate over business concepts
- Bury business rules inside control flow structures
- Mix data representation with processing logic
- Assume numeric sequences represent business relationships

## Further Reading

- [Clean Code: A Handbook of Agile Software Craftsmanship](https://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882)
- [Refactoring: Improving the Design of Existing Code](https://martinfowler.com/books/refactoring.html)
- [Code Complete: A Practical Handbook of Software Construction](https://www.amazon.com/Code-Complete-Practical-Handbook-Construction/dp/0735619670)

## Contributing

When contributing to this example, please:
1. Keep examples generic and applicable to any domain
2. Focus on fundamental programming principles
3. Provide clear before/after comparisons
4. Include unit tests for any new examples
5. Update documentation to reflect changes

## License

This educational example is provided under the AGPLv3 License.

âš ï¸ AI Disclosure: 
This project includes code generated with assistance from Large Language Models (LLMs) including Claude. 
Use at your own discretion.



===============================================================================
EXPORT COMPLETED: 09/18/2025 16:18:51
Total Files Exported: 9
Output File: C:\Users\kushal\source\repos\AvoidMagicNumbers\llm\dump.txt
===============================================================================
