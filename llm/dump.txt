
===============================================================================
ASP.NET PROJECT EXPORT
Generated: 09/18/2025 15:48:48
Project Path: C:\Users\kushal\source\repos\AvoidMagicNumbers
===============================================================================

DIRECTORY STRUCTURE:
===================

Folder PATH listing
Volume serial number is 9892-5BAD
C:\USERS\KUSHAL\SOURCE\REPOS\AVOIDMAGICNUMBERS
|   .gitattributes
|   .gitignore
|   AvoidMagicNumbers.slnx
|   Export-Project.ps1
|   README.md
|   
+---.github
|   \---workflows
|           build-and-test.yml
|           
+---AntiPattern
|       AntiPattern.csproj
|       RoleAssignmentService_BadWay.cs
|       
+---DemonstrationConsole
|       DemonstrationConsole.csproj
|       Program.cs
|       
+---llm
|       dump.txt
|       
\---ModernApproach
        ModernApproach.csproj
        RoleAssignmentService_GoodWay.cs
        


FILE CONTENTS:
==============

================================================================================
FILE: .github\workflows\build-and-test.yml
SIZE: 1.8 KB
MODIFIED: 09/18/2025 13:48:29
================================================================================

name: Build and Test

on:
  push:
    branches: [ master, main, develop ]
  pull_request:
    branches: [ main, master ]

jobs:
  build-and-test:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v5
    
    - name: Setup .NET
      uses: actions/setup-dotnet@v5
      with:
        dotnet-version: '10.0.x'
        include-prerelease: true
    
    - name: Restore dependencies
      run: dotnet restore
    
    - name: Build
      run: dotnet build --no-restore --configuration Release
    
    - name: Run demonstration
      run: |
        echo "Running magic numbers demonstration..."
        dotnet run --project DemonstrationConsole --configuration Release --no-build
        echo "Demo completed successfully!"
    
    - name: Verify build artifacts
      run: |
        echo "Checking build outputs..."
        ls -la */bin/Release/net10.0/
        echo "All artifacts present!"

  build-matrix:
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
        dotnet-version: ['10.0.x']
    
    runs-on: ${{ matrix.os }}
    
    steps:
    - uses: actions/checkout@v5
    
    - name: Setup .NET ${{ matrix.dotnet-version }}
      uses: actions/setup-dotnet@v5
      with:
        dotnet-version: ${{ matrix.dotnet-version }}
        include-prerelease: true
    
    - name: Restore dependencies
      run: dotnet restore
    
    - name: Build
      run: dotnet build --no-restore --configuration Release
    
    - name: Run demo on ${{ matrix.os }}
      run: dotnet run --project DemonstrationConsole --configuration Release --no-build
    
    - name: Test clean build
      run: |
        dotnet clean
        dotnet build --configuration Release
        echo "Clean build successful on ${{ matrix.os }}"



================================================================================
FILE: AntiPattern\AntiPattern.csproj
SIZE: 0.21 KB
MODIFIED: 09/18/2025 10:31:58
================================================================================

<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net10.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>

</Project>



================================================================================
FILE: AntiPattern\RoleAssignmentService_BadWay.cs
SIZE: 3.38 KB
MODIFIED: 09/18/2025 10:55:43
================================================================================

// ============================================
// ANTI-PATTERN: Using Magic Numbers in Loops
// ============================================

namespace AntiPattern
{
    public class RoleAssignmentService_BadWay
    {
        private Dictionary<string, object> parameters = new Dictionary<string, object>();

        public void AssignStandardRoles(string userId, string departmentId, DateTime assignedDate)
        {
            // PROBLEM 1: Magic numbers in loop - what do 6 and 7 represent?
            for (int i = 6; i <= 7; i++)
            {
                string roleId = Guid.NewGuid().ToString();
                string assignmentId = Guid.NewGuid().ToString();
                string supervisorId = null;

                // PROBLEM 2: Building parameters inside loop with unclear logic
                parameters.Clear();
                parameters.Add("RoleId", roleId);
                parameters.Add("AssignmentId", assignmentId);
                parameters.Add("UserId", userId);
                parameters.Add("DepartmentId", departmentId);
                parameters.Add("AssignedDate", assignedDate);

                // PROBLEM 3: Hard-coded conditionals based on magic numbers
                if (i == 6) // What business rule does "6" represent?
                {
                    supervisorId = GetDepartmentManager(departmentId);
                    parameters.Add("RoleTypeCode", i);
                    parameters.Add("SupervisorId", supervisorId);

                    Console.WriteLine($"Assigning role type {i} (what role?) to user {userId}");

                    // PROBLEM 4: Database calls scattered throughout loop
                    ExecuteDatabaseCommand("InsertUserRole", parameters);

                    // PROBLEM 5: More magic numbers in related method calls
                    CreateWorkAssignment(supervisorId, 101, userId, 25); // 101? 25?
                }
                else if (i == 7) // What business rule does "7" represent?
                {
                    supervisorId = GetProjectCoordinator(departmentId);
                    parameters.Add("RoleTypeCode", i);
                    parameters.Add("SupervisorId", supervisorId);

                    Console.WriteLine($"Assigning role type {i} (what role?) to user {userId}");
                    ExecuteDatabaseCommand("InsertUserRole", parameters);

                    // PROBLEM 6: Complex conditional logic with more magic numbers
                    var workRoleCode = (IsSpecialDepartment(departmentId) ? 202 : 203);
                    CreateWorkAssignment(supervisorId, workRoleCode, userId, 25);
                }
            }
        }

        private void ExecuteDatabaseCommand(string command, Dictionary<string, object> parameters)
        {
            Console.WriteLine($"  Executing {command} with {parameters.Count} parameters");
        }

        private void CreateWorkAssignment(string supervisorId, int roleCode, string userId, int resourceType)
        {
            Console.WriteLine($"  Creating work assignment: Supervisor={supervisorId}, RoleCode={roleCode}, ResourceType={resourceType}");
        }

        private string GetDepartmentManager(string departmentId) => "manager-" + departmentId;
        private string GetProjectCoordinator(string departmentId) => "coordinator-" + departmentId;
        private bool IsSpecialDepartment(string departmentId) => departmentId.ToUpper() == "SPECIAL-DEPT";
    }
}



================================================================================
FILE: AvoidMagicNumbers.slnx
SIZE: 0.2 KB
MODIFIED: 09/18/2025 10:33:39
================================================================================

<Solution>
  <Project Path="AntiPattern/AntiPattern.csproj" />
  <Project Path="DemonstrationConsole/DemonstrationConsole.csproj" />
  <Project Path="ModernApproach/ModernApproach.csproj" />
</Solution>



================================================================================
FILE: DemonstrationConsole\DemonstrationConsole.csproj
SIZE: 0.42 KB
MODIFIED: 09/18/2025 10:33:39
================================================================================

<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net10.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>

  <ItemGroup>
    <ProjectReference Include="..\AntiPattern\AntiPattern.csproj" />
    <ProjectReference Include="..\ModernApproach\ModernApproach.csproj" />
  </ItemGroup>

</Project>



================================================================================
FILE: DemonstrationConsole\Program.cs
SIZE: 3.25 KB
MODIFIED: 09/18/2025 15:47:12
================================================================================

// ============================================
// DEMONSTRATION
// ============================================

using ModernApproach;

class Program
{
    static void Main(string[] args)
    {
        Console.WriteLine("=== ANTI-PATTERN: Magic Numbers in Loops ===");
        Console.WriteLine("- for (int i = 6; i <= 7; i++) - what do these numbers mean?");
        Console.WriteLine("- Hard-coded conditions based on loop counter values");
        Console.WriteLine("- Business logic buried inside loop iteration");
        Console.WriteLine("- Additional magic numbers scattered throughout (101, 202, 203, 25)");
        Console.WriteLine();

        var badService = new AntiPattern.RoleAssignmentService_BadWay();
        badService.AssignStandardRoles("user123", "IT-DEPT", DateTime.Now);

        Console.WriteLine();
        Console.WriteLine("=== MODERN APPROACH: Type-Safe, Explicit Business Logic ===");
        Console.WriteLine("Benefits of this refactored approach:");
        Console.WriteLine("- Eliminates magic number loop entirely");
        Console.WriteLine("- Strong types prevent parameter mix-ups at compile time");
        Console.WriteLine("- Command objects replace loose parameter dictionaries");
        Console.WriteLine("- Immutable records with clear business meaning");
        Console.WriteLine("- Type-safe comparisons instead of string manipulation");
        Console.WriteLine("- Each role assignment is explicit and testable");
        Console.WriteLine();

        var goodService = ModernApproach.DemoRoleAssignmentService.Create();
        goodService.AssignStandardRoles(new UserId("user123"), new DepartmentId("IT-DEPT"), DateTime.Now);

        Console.WriteLine();
        Console.WriteLine("1. ELIMINATE MAGIC NUMBER LOOPS");
        Console.WriteLine("   Replace: for (int i = 6; i <= 7; i++)");
        Console.WriteLine("   With: foreach (var role in GetRequiredRoles())");
        Console.WriteLine();
        Console.WriteLine("2. USE DESCRIPTIVE ENUMS");
        Console.WriteLine("   Replace: if (i == 6) // FOAOwner");
        Console.WriteLine("   With: if (role.Type == SolicitationRoleType.FOAOwner)");
        Console.WriteLine();
        Console.WriteLine("3. CREATE STRONGLY-TYPED DOMAIN OBJECTS");
        Console.WriteLine("   Replace: string userId, string departmentId");
        Console.WriteLine("   With: UserId userId, DepartmentId departmentId");
        Console.WriteLine();
        Console.WriteLine("4. USE COMMAND OBJECTS INSTEAD OF DICTIONARIES");
        Console.WriteLine("   Replace: parameters.Add(\"UserId\", userId)");
        Console.WriteLine("   With: new CreateUserRoleCommand(userId, departmentId, ...)");
        Console.WriteLine();
        Console.WriteLine("5. LEVERAGE COMPILE-TIME TYPE SAFETY");
        Console.WriteLine("   Replace: String comparisons and casting");
        Console.WriteLine("   With: Record equality and strong typing");
        Console.WriteLine();
        Console.WriteLine("This pattern applies to your dependency injection work:");
        Console.WriteLine("- Replace ServiceFactory static calls with injected dependencies");
        Console.WriteLine("- Make configuration paths explicit parameters");
        Console.WriteLine("- Use constructor injection instead of hidden factory dependencies");
    }
}



================================================================================
FILE: ModernApproach\ModernApproach.csproj
SIZE: 0.21 KB
MODIFIED: 09/18/2025 10:32:42
================================================================================

<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net10.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>

</Project>



================================================================================
FILE: ModernApproach\RoleAssignmentService_GoodWay.cs
SIZE: 26.07 KB
MODIFIED: 09/18/2025 15:48:12
================================================================================

// ============================================
// MODERN APPROACH: Explicit, Readable Role Assignment with DI
// ============================================

namespace ModernApproach
{
    // ============================================
    // STRONG TYPES - Prevent primitive obsession
    // ============================================
    
    public record UserId(string Value)
    {
        public static implicit operator string(UserId userId) => userId.Value;
        public override string ToString() => Value;
    }
    
    public sealed record DepartmentId(string Value) : IEquatable<DepartmentId>
    {
        public static implicit operator string(DepartmentId departmentId) => departmentId.Value;
        public override string ToString() => Value;
        
        // Custom equality for case-insensitive comparison
        public bool Equals(DepartmentId? other)
        {
            return other is not null && 
                   string.Equals(Value, other.Value, StringComparison.OrdinalIgnoreCase);
        }
        
        public override int GetHashCode() => 
            Value.ToUpperInvariant().GetHashCode();
    }
    
    public record SupervisorId(string Value)
    {
        public static implicit operator string(SupervisorId supervisorId) => supervisorId.Value;
        public override string ToString() => Value;
    }
    
    public record RoleId(Guid Value)
    {
        public static RoleId New() => new(Guid.NewGuid());
        public static implicit operator Guid(RoleId roleId) => roleId.Value;
        public override string ToString() => Value.ToString();
    }
    
    public record AssignmentId(Guid Value)
    {
        public static AssignmentId New() => new(Guid.NewGuid());
        public static implicit operator Guid(AssignmentId assignmentId) => assignmentId.Value;
        public override string ToString() => Value.ToString();
    }

    // ============================================
    // ENUMS - Document business meaning
    // ============================================
    
    public enum StandardRoleType
    {
        DepartmentManager = 6,    // Maintaining original DB values for compatibility
        ProjectCoordinator = 7
    }

    public enum WorkAssignmentRoleCode
    {
        ProjectManager = 101,
        GeneralAdministrator = 203,
        SpecialAdministrator = 202
    }

    public enum ResourceType
    {
        UserAccount = 25
    }

    // ============================================
    // CONSTANTS - Centralized configuration
    // ============================================
    
    public static class RoleAssignmentConstants
    {
        public const string ManagerPrefix = "manager-";
        public const string CoordinatorPrefix = "coordinator-";
        
        public static class Descriptions
        {
            public const string DepartmentManager = "Department Manager - oversees department operations";
            public const string ProjectCoordinator = "Project Coordinator - manages project workflows";
        }
        
        public static class ValidationMessages
        {
            public const string UserAlreadyHasRole = "User already has role {0}";
            public const string SupervisorNotFound = "Supervisor {0} not found";
            public const string InvalidUserId = "User ID cannot be null or empty";
            public const string InvalidDepartmentId = "Department ID cannot be null or empty";
        }
    }

    // ============================================
    // DATA STRUCTURES - Immutable domain models
    // ============================================
    
    public record RoleAssignment(
        StandardRoleType RoleType,
        SupervisorId SupervisorId,
        WorkAssignmentRoleCode WorkRole,
        string Description
    );

    public record CreateUserRoleCommand(
        RoleId RoleId,
        AssignmentId AssignmentId,
        UserId UserId,
        DepartmentId DepartmentId,
        DateTime AssignedDate,
        StandardRoleType RoleType,
        SupervisorId SupervisorId
    );

    public record WorkAssignmentCommand(
        SupervisorId SupervisorId,
        WorkAssignmentRoleCode RoleCode,
        UserId UserId,
        ResourceType ResourceType,
        DateTime CreatedDate
    );

    public sealed record RoleAssignmentResult
    {
        public bool IsSuccess { get; init; }
        public IReadOnlyList<string> Errors { get; init; } = Array.Empty<string>();
        public IReadOnlyList<RoleId> AssignedRoleIds { get; init; } = Array.Empty<RoleId>();
        
        public static RoleAssignmentResult Success(params RoleId[] roleIds) => 
            new() { IsSuccess = true, AssignedRoleIds = roleIds.ToList().AsReadOnly() };
        
        public static RoleAssignmentResult Failure(params string[] errors) => 
            new() { IsSuccess = false, Errors = errors.ToList().AsReadOnly() };
    }

    public sealed record ValidationResult(bool IsValid, IReadOnlyList<string> Errors)
    {
        public static ValidationResult Success() => new(true, Array.Empty<string>());
        public static ValidationResult Failure(params string[] errors) => 
            new(false, errors.ToList().AsReadOnly());
    }

    // ============================================
    // CONFIGURATION - Externalized settings
    // ============================================
    
    public sealed class RoleAssignmentConfiguration
    {
        public IReadOnlySet<DepartmentId> SpecialDepartmentCodes { get; init; } = 
            new HashSet<DepartmentId> { new("SPECIAL-DEPT") };
        public bool IsVerboseLoggingEnabled { get; init; }
        public bool ValidateExistingRoles { get; init; } = true;
        public TimeSpan TransactionTimeout { get; init; } = TimeSpan.FromMinutes(5);
    }

    // ============================================
    // INTERFACES - Dependency abstractions
    // ============================================
    
    public interface IUserRoleRepository
    {
        Task<int> CreateUserRoleAsync(CreateUserRoleCommand command, CancellationToken cancellationToken = default);
        Task<bool> UserRoleExistsAsync(UserId userId, StandardRoleType roleType, CancellationToken cancellationToken = default);
    }

    public interface IWorkAssignmentRepository
    {
        Task<int> CreateWorkAssignmentAsync(WorkAssignmentCommand command, CancellationToken cancellationToken = default);
    }

    public interface ISupervisorService
    {
        Task<SupervisorId> GetDepartmentManagerAsync(DepartmentId departmentId, CancellationToken cancellationToken = default);
        Task<SupervisorId> GetProjectCoordinatorAsync(DepartmentId departmentId, CancellationToken cancellationToken = default);
        Task<bool> SupervisorExistsAsync(SupervisorId supervisorId, CancellationToken cancellationToken = default);
    }

    public interface ILogger
    {
        void LogInformation(string message, params object[] args);
        void LogDebug(string message, params object[] args);
        void LogError(Exception ex, string message, params object[] args);
        void LogWarning(string message, params object[] args);
    }

    public interface IUnitOfWork
    {
        Task BeginTransactionAsync(CancellationToken cancellationToken = default);
        Task CommitAsync(CancellationToken cancellationToken = default);
        Task RollbackAsync(CancellationToken cancellationToken = default);
    }

    public interface IRoleAssignmentFactory
    {
        Task<IReadOnlyList<RoleAssignment>> CreateStandardAssignmentsAsync(DepartmentId departmentId, CancellationToken cancellationToken = default);
    }

    // ============================================
    // EXTENSION METHODS - Clean code helpers
    // ============================================
    
    public static class RoleAssignmentExtensions
    {
        public static bool RequiresSpecialHandling(this StandardRoleType roleType)
        {
            return roleType == StandardRoleType.ProjectCoordinator;
        }
        
        public static string GetDisplayName(this StandardRoleType roleType)
        {
            return roleType switch
            {
                StandardRoleType.DepartmentManager => "Department Manager",
                StandardRoleType.ProjectCoordinator => "Project Coordinator",
                _ => roleType.ToString()
            };
        }
    }

    // ============================================
    // FACTORY - Creates role assignments
    // ============================================
    
    public sealed class RoleAssignmentFactory : IRoleAssignmentFactory
    {
        private readonly ISupervisorService supervisorService;
        private readonly RoleAssignmentConfiguration configuration;
        
        public RoleAssignmentFactory(
            ISupervisorService supervisorService,
            RoleAssignmentConfiguration configuration)
        {
            this.supervisorService = supervisorService ?? throw new ArgumentNullException(nameof(supervisorService));
            this.configuration = configuration ?? throw new ArgumentNullException(nameof(configuration));
        }
        
        public async Task<IReadOnlyList<RoleAssignment>> CreateStandardAssignmentsAsync(
            DepartmentId departmentId, 
            CancellationToken cancellationToken = default)
        {
            var assignments = new List<RoleAssignment>();
            
            // Department Manager Role
            var managerSupervisor = await supervisorService.GetDepartmentManagerAsync(departmentId, cancellationToken);
            assignments.Add(new RoleAssignment(
                StandardRoleType.DepartmentManager,
                managerSupervisor,
                WorkAssignmentRoleCode.ProjectManager,
                RoleAssignmentConstants.Descriptions.DepartmentManager
            ));
            
            // Project Coordinator Role
            var coordinatorSupervisor = await supervisorService.GetProjectCoordinatorAsync(departmentId, cancellationToken);
            var coordinatorWorkRole = GetCoordinatorWorkRole(departmentId);
            assignments.Add(new RoleAssignment(
                StandardRoleType.ProjectCoordinator,
                coordinatorSupervisor,
                coordinatorWorkRole,
                RoleAssignmentConstants.Descriptions.ProjectCoordinator
            ));
            
            return assignments.AsReadOnly();
        }
        
        private WorkAssignmentRoleCode GetCoordinatorWorkRole(DepartmentId departmentId)
        {
            var isSpecialDepartment = configuration.SpecialDepartmentCodes.Contains(departmentId);
            return isSpecialDepartment
                ? WorkAssignmentRoleCode.SpecialAdministrator
                : WorkAssignmentRoleCode.GeneralAdministrator;
        }
    }

    // ============================================
    // SERVICE - Main business logic with DI
    // ============================================
    
    public sealed class RoleAssignmentService_GoodWay
    {
        private readonly IUserRoleRepository userRoleRepository;
        private readonly IWorkAssignmentRepository workAssignmentRepository;
        private readonly ISupervisorService supervisorService;
        private readonly IRoleAssignmentFactory roleAssignmentFactory;
        private readonly IUnitOfWork unitOfWork;
        private readonly ILogger logger;
        private readonly RoleAssignmentConfiguration configuration;

        // Constructor with dependency injection
        public RoleAssignmentService_GoodWay(
            IUserRoleRepository userRoleRepository,
            IWorkAssignmentRepository workAssignmentRepository,
            ISupervisorService supervisorService,
            IRoleAssignmentFactory roleAssignmentFactory,
            IUnitOfWork unitOfWork,
            ILogger logger,
            RoleAssignmentConfiguration configuration)
        {
            this.userRoleRepository = userRoleRepository ?? throw new ArgumentNullException(nameof(userRoleRepository));
            this.workAssignmentRepository = workAssignmentRepository ?? throw new ArgumentNullException(nameof(workAssignmentRepository));
            this.supervisorService = supervisorService ?? throw new ArgumentNullException(nameof(supervisorService));
            this.roleAssignmentFactory = roleAssignmentFactory ?? throw new ArgumentNullException(nameof(roleAssignmentFactory));
            this.unitOfWork = unitOfWork ?? throw new ArgumentNullException(nameof(unitOfWork));
            this.logger = logger ?? throw new ArgumentNullException(nameof(logger));
            this.configuration = configuration ?? throw new ArgumentNullException(nameof(configuration));
        }

        // Main public method - async with result pattern and cancellation support
        public async Task<RoleAssignmentResult> AssignStandardRolesAsync(
            UserId userId, 
            DepartmentId departmentId, 
            DateTime assignedDate,
            CancellationToken cancellationToken = default)
        {
            // Input validation
            ArgumentNullException.ThrowIfNull(userId);
            ArgumentNullException.ThrowIfNull(departmentId);
            
            if (string.IsNullOrWhiteSpace(userId.Value))
                throw new ArgumentException("User ID cannot be null or empty", nameof(userId));
            
            if (string.IsNullOrWhiteSpace(departmentId.Value))
                throw new ArgumentException("Department ID cannot be null or empty", nameof(departmentId));

            logger.LogInformation(
                "Starting role assignment for user {0} in department {1}",
                userId.Value,
                departmentId.Value);

            var assignedRoleIds = new List<RoleId>();

            try
            {
                using var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
                cts.CancelAfter(configuration.TransactionTimeout);

                await unitOfWork.BeginTransactionAsync(cts.Token);
                
                // Get the roles this user should have
                var roleAssignments = await roleAssignmentFactory.CreateStandardAssignmentsAsync(departmentId, cts.Token);
                
                // Process each role with validation
                foreach (var assignment in roleAssignments)
                {
                    var validation = await ValidateRoleAssignmentAsync(userId, departmentId, assignment, cts.Token);
                    if (!validation.IsValid)
                    {
                        logger.LogWarning(
                            "Validation failed for role {0}: {1}",
                            assignment.RoleType,
                            string.Join(", ", validation.Errors));
                        
                        if (configuration.ValidateExistingRoles)
                        {
                            await unitOfWork.RollbackAsync(cts.Token);
                            return RoleAssignmentResult.Failure(validation.Errors.ToArray());
                        }
                        continue;
                    }
                    
                    var roleId = await ProcessSingleRoleAssignmentAsync(userId, departmentId, assignedDate, assignment, cts.Token);
                    if (roleId != null)
                    {
                        assignedRoleIds.Add(roleId);
                    }
                }
                
                await unitOfWork.CommitAsync(cts.Token);
                
                logger.LogInformation(
                    "Successfully assigned {0} roles to user {1}",
                    assignedRoleIds.Count,
                    userId.Value);
                
                return RoleAssignmentResult.Success(assignedRoleIds.ToArray());
            }
            catch (OperationCanceledException)
            {
                logger.LogWarning("Role assignment operation was cancelled for user {0}", userId.Value);
                await unitOfWork.RollbackAsync(CancellationToken.None);
                return RoleAssignmentResult.Failure("Operation was cancelled");
            }
            catch (Exception ex)
            {
                logger.LogError(ex, 
                    "Failed to assign roles for user {0} in department {1}",
                    userId.Value,
                    departmentId.Value);
                
                await unitOfWork.RollbackAsync(CancellationToken.None);
                return RoleAssignmentResult.Failure($"Role assignment failed: {ex.Message}");
            }
        }

        // Synchronous overload for backward compatibility
        public void AssignStandardRoles(UserId userId, DepartmentId departmentId, DateTime assignedDate)
        {
            var result = AssignStandardRolesAsync(userId, departmentId, assignedDate).GetAwaiter().GetResult();
            if (!result.IsSuccess)
            {
                throw new InvalidOperationException($"Role assignment failed: {string.Join(", ", result.Errors)}");
            }
        }

        private async Task<ValidationResult> ValidateRoleAssignmentAsync(
            UserId userId, 
            DepartmentId departmentId,
            RoleAssignment assignment,
            CancellationToken cancellationToken)
        {
            var errors = new List<string>();
            
            // Check if user already has this role
            if (configuration.ValidateExistingRoles)
            {
                if (await userRoleRepository.UserRoleExistsAsync(userId, assignment.RoleType, cancellationToken))
                {
                    errors.Add(string.Format(
                        RoleAssignmentConstants.ValidationMessages.UserAlreadyHasRole,
                        assignment.RoleType.GetDisplayName()));
                }
            }
            
            // Validate supervisor exists
            if (!await supervisorService.SupervisorExistsAsync(assignment.SupervisorId, cancellationToken))
            {
                errors.Add(string.Format(
                    RoleAssignmentConstants.ValidationMessages.SupervisorNotFound,
                    assignment.SupervisorId.Value));
            }
            
            return errors.Count > 0 
                ? ValidationResult.Failure(errors.ToArray()) 
                : ValidationResult.Success();
        }

        private async Task<RoleId> ProcessSingleRoleAssignmentAsync(
            UserId userId, 
            DepartmentId departmentId,
            DateTime assignedDate, 
            RoleAssignment assignment,
            CancellationToken cancellationToken)
        {
            var roleId = RoleId.New();
            var assignmentId = AssignmentId.New();
            
            // Create strongly-typed command object
            var command = new CreateUserRoleCommand(
                roleId,
                assignmentId,
                userId,
                departmentId,
                assignedDate,
                assignment.RoleType,
                assignment.SupervisorId
            );

            logger.LogInformation(
                "Assigning {0} role to user {1}",
                assignment.RoleType.GetDisplayName(),
                userId.Value);
            
            if (configuration.IsVerboseLoggingEnabled)
            {
                logger.LogDebug(
                    "Role assignment details - RoleId: {0}, SupervisorId: {1}, Description: {2}",
                    roleId.Value,
                    assignment.SupervisorId.Value,
                    assignment.Description);
            }

            try
            {
                // Execute database command through repository
                await userRoleRepository.CreateUserRoleAsync(command, cancellationToken);
                
                // Create work assignment
                var workCommand = new WorkAssignmentCommand(
                    assignment.SupervisorId,
                    assignment.WorkRole,
                    userId,
                    ResourceType.UserAccount,
                    assignedDate
                );
                
                await workAssignmentRepository.CreateWorkAssignmentAsync(workCommand, cancellationToken);
                
                logger.LogDebug(
                    "Successfully created role assignment {0} for user {1}",
                    roleId.Value,
                    userId.Value);
                
                return roleId;
            }
            catch (Exception ex)
            {
                logger.LogError(ex, 
                    "Failed to process role assignment {0} for user {1}",
                    assignment.RoleType,
                    userId.Value);
                throw;
            }
        }
    }

    // ============================================
    // DEFAULT IMPLEMENTATIONS - For demo/testing
    // ============================================
    
    // Simple console logger for demonstration
    public sealed class ConsoleLogger : ILogger
    {
        public void LogInformation(string message, params object[] args)
        {
            try
            {
                Console.WriteLine($"[INFO] {string.Format(message, args)}");
            }
            catch (FormatException)
            {
                Console.WriteLine($"[INFO] {message}");
            }
        }

        public void LogDebug(string message, params object[] args)
        {
            try
            {
                Console.WriteLine($"[DEBUG] {string.Format(message, args)}");
            }
            catch (FormatException)
            {
                Console.WriteLine($"[DEBUG] {message}");
            }
        }

        public void LogError(Exception ex, string message, params object[] args)
        {
            try
            {
                Console.WriteLine($"[ERROR] {string.Format(message, args)} - Exception: {ex.Message}");
            }
            catch (FormatException)
            {
                Console.WriteLine($"[ERROR] {message} - Exception: {ex.Message}");
            }
        }

        public void LogWarning(string message, params object[] args)
        {
            try
            {
                Console.WriteLine($"[WARN] {string.Format(message, args)}");
            }
            catch (FormatException)
            {
                Console.WriteLine($"[WARN] {message}");
            }
        }
    }

    // Demo implementations for testing without actual database
    public sealed class DemoUserRoleRepository : IUserRoleRepository
    {
        public Task<int> CreateUserRoleAsync(CreateUserRoleCommand command, CancellationToken cancellationToken = default)
        {
            Console.WriteLine($"  [REPO] Creating user role - RoleId: {command.RoleId.Value}, UserId: {command.UserId.Value}");
            return Task.FromResult(1);
        }

        public Task<bool> UserRoleExistsAsync(UserId userId, StandardRoleType roleType, CancellationToken cancellationToken = default)
        {
            return Task.FromResult(false); // Always return false for demo
        }
    }

    public sealed class DemoWorkAssignmentRepository : IWorkAssignmentRepository
    {
        public Task<int> CreateWorkAssignmentAsync(WorkAssignmentCommand command, CancellationToken cancellationToken = default)
        {
            Console.WriteLine($"  [REPO] Creating work assignment - Supervisor: {command.SupervisorId.Value}, Role: {command.RoleCode}");
            return Task.FromResult(1);
        }
    }

    public sealed class DemoSupervisorService : ISupervisorService
    {
        public Task<SupervisorId> GetDepartmentManagerAsync(DepartmentId departmentId, CancellationToken cancellationToken = default)
        {
            return Task.FromResult(new SupervisorId($"{RoleAssignmentConstants.ManagerPrefix}{departmentId.Value}"));
        }

        public Task<SupervisorId> GetProjectCoordinatorAsync(DepartmentId departmentId, CancellationToken cancellationToken = default)
        {
            return Task.FromResult(new SupervisorId($"{RoleAssignmentConstants.CoordinatorPrefix}{departmentId.Value}"));
        }

        public Task<bool> SupervisorExistsAsync(SupervisorId supervisorId, CancellationToken cancellationToken = default)
        {
            return Task.FromResult(true); // Always return true for demo
        }
    }

    public sealed class DemoUnitOfWork : IUnitOfWork
    {
        public Task BeginTransactionAsync(CancellationToken cancellationToken = default)
        {
            Console.WriteLine("  [UOW] Beginning transaction");
            return Task.CompletedTask;
        }

        public Task CommitAsync(CancellationToken cancellationToken = default)
        {
            Console.WriteLine("  [UOW] Committing transaction");
            return Task.CompletedTask;
        }

        public Task RollbackAsync(CancellationToken cancellationToken = default)
        {
            Console.WriteLine("  [UOW] Rolling back transaction");
            return Task.CompletedToken;
        }
    }

    // ============================================
    // DEMO FACTORY - For backward compatibility
    // ============================================
    
    public sealed class DemoRoleAssignmentService
    {
        public static RoleAssignmentService_GoodWay Create()
        {
            var configuration = new RoleAssignmentConfiguration();
            var logger = new ConsoleLogger();
            var supervisorService = new DemoSupervisorService();
            
            return new RoleAssignmentService_GoodWay(
                new DemoUserRoleRepository(),
                new DemoWorkAssignmentRepository(),
                supervisorService,
                new RoleAssignmentFactory(supervisorService, configuration),
                new DemoUnitOfWork(),
                logger,
                configuration
            );
        }
    }
}



================================================================================
FILE: README.md
SIZE: 8.54 KB
MODIFIED: 09/18/2025 10:45:53
================================================================================

# Eliminating Magic Numbers: From Anti-Pattern to Clean Code

## Overview

This repository demonstrates a common but problematic coding pattern known as "magic numbers" and shows how to refactor it into maintainable, self-documenting code. This anti-pattern is frequently found in enterprise codebases and can significantly impact code readability, maintainability, and team productivity.

## The Problem: Magic Numbers in Control Flow

### What Are Magic Numbers?

Magic numbers are numeric literals that appear in code without explanation of their meaning or purpose. They're called "magic" because their significance is hidden from anyone reading the code.

### The Anti-Pattern in Action

Consider this common pattern found in many enterprise applications:

```csharp
for (int i = 6; i <= 7; i++)
{
    if (i == 6)
    {
        // Some business logic for "6"
        DoSomething(i, "SomeValue");
        CallAnotherMethod(101, userId, 25);
    }
    else if (i == 7)  
    {
        // Different business logic for "7"
        DoSomethingElse(i, "AnotherValue");
        CallAnotherMethod(203, userId, 25);
    }
}
```

### Why This Is Problematic

1. **Unclear Intent**: What do the numbers 6 and 7 represent? What business concepts do they model?

2. **Hidden Business Logic**: The loop structure suggests we're iterating over a sequence, but we're actually processing specific, discrete business cases.

3. **Maintenance Nightmare**: Adding a new case requires modifying the loop bounds and adding another conditional branch.

4. **Scattered Magic Numbers**: Additional magic numbers (101, 203, 25) appear throughout the code with no context.

5. **Poor Testability**: It's difficult to test individual business cases when they're buried inside loop iterations.

6. **Misleading Abstractions**: The loop implies a mathematical sequence when the problem is actually about distinct business entities.

## The Solution: Explicit Business Modeling

### Step 1: Replace Magic Numbers with Enums

```csharp
public enum BusinessRoleType
{
    DepartmentManager = 6,    // Preserve original DB values if needed
    ProjectCoordinator = 7
}

public enum WorkAssignmentCode
{
    ProjectManager = 101,
    GeneralAdministrator = 203,
    SpecialAdministrator = 202
}
```

### Step 2: Create Explicit Data Structures

```csharp
public class RoleAssignment
{
    public BusinessRoleType RoleType { get; set; }
    public string SupervisorId { get; set; }
    public WorkAssignmentCode WorkRole { get; set; }
    public string Description { get; set; }
}
```

### Step 3: Replace Loops with Explicit Collections

```csharp
private List<RoleAssignment> GetRequiredRoleAssignments(string departmentId)
{
    return new List<RoleAssignment>
    {
        new RoleAssignment
        {
            RoleType = BusinessRoleType.DepartmentManager,
            SupervisorId = GetDepartmentManager(departmentId),
            WorkRole = WorkAssignmentCode.ProjectManager,
            Description = "Department Manager - oversees operations"
        },
        new RoleAssignment
        {
            RoleType = BusinessRoleType.ProjectCoordinator,
            SupervisorId = GetProjectCoordinator(departmentId),
            WorkRole = GetCoordinatorWorkRole(departmentId),
            Description = "Project Coordinator - manages workflows"
        }
    };
}
```

### Step 4: Process Each Item Explicitly

```csharp
public void AssignStandardRoles(string userId, string departmentId, DateTime assignedDate)
{
    var roleAssignments = GetRequiredRoleAssignments(departmentId);

    foreach (var assignment in roleAssignments)
    {
        ProcessSingleRoleAssignment(userId, departmentId, assignedDate, assignment);
    }
}
```

## Running the Example

```bash
dotnet run
```

The program will demonstrate both approaches side-by-side, showing the difference in clarity and maintainability.

## Key Benefits of the Refactored Approach

### 1. Self-Documenting Code
- Enum names immediately convey business meaning
- No need to look up what numbers represent
- Code reads like business requirements

### 2. Improved Maintainability
- Adding new roles requires adding to the enum and collection
- No complex loop modifications
- Changes are localized and predictable

### 3. Better Testability
- Each role assignment can be tested independently
- Business logic is separated from iteration logic
- Mock data is easier to create and understand

### 4. Type Safety
- Compiler catches incorrect enum usage
- IntelliSense provides meaningful options
- Refactoring tools work more effectively

### 5. Clear Separation of Concerns
- Data structure definition is separate from processing logic
- Business rules are explicit and centralized
- Database operations are isolated from business logic

## Common Variations of This Anti-Pattern

### Switch Statements on Magic Numbers
```csharp
// Anti-pattern
switch (statusCode)
{
    case 1: // What does 1 mean?
        HandleApproved();
        break;
    case 2: // What does 2 mean?
        HandleRejected();
        break;
}

// Better approach
switch (status)
{
    case ApprovalStatus.Approved:
        HandleApproved();
        break;
    case ApprovalStatus.Rejected:
        HandleRejected();
        break;
}
```

### Configuration-Based Magic Numbers
```csharp
// Anti-pattern
if (userType == 3 && accessLevel >= 5)
{
    // Business logic here
}

// Better approach  
if (user.Type == UserType.Administrator && 
    user.AccessLevel >= AccessLevel.FullAccess)
{
    // Business logic here
}
```

## When to Apply This Refactoring

### Red Flags to Watch For
- Loops that iterate over a small, fixed range of numbers
- Multiple `if` statements checking specific numeric values
- Comments that explain what numbers represent
- Database queries with hard-coded numeric parameters
- Complex conditional logic based on numeric ranges

### Safe Refactoring Steps
1. **Identify the business concepts** behind the magic numbers
2. **Create enums** with descriptive names
3. **Extract data structures** that model the business domain
4. **Replace loops** with explicit collections or method calls
5. **Move complex logic** into separate, well-named methods
6. **Add unit tests** for each business scenario

## Legacy System Considerations

### Maintaining Database Compatibility
When refactoring legacy systems, you may need to preserve the original numeric values:

```csharp
public enum LegacyStatusCode
{
    [Description("Pending Review")]
    PendingReview = 1,
    
    [Description("Under Investigation")]  
    UnderInvestigation = 3,
    
    [Description("Approved")]
    Approved = 7  // Skip 2,4,5,6 for historical reasons
}
```

### Gradual Migration Strategy
1. Create enums alongside existing magic numbers
2. Add conversion methods between old and new representations
3. Update one module at a time
4. Maintain backward compatibility during transition
5. Remove magic numbers once all dependent code is updated

## Best Practices Summary

### Do
- Use descriptive enum names that reflect business concepts
- Group related constants into cohesive enums
- Add XML documentation to explain business rules
- Create explicit data structures for complex business entities
- Write unit tests for each business scenario

### Don't
- Use magic numbers for business logic decisions
- Create loops that iterate over business concepts
- Bury business rules inside control flow structures
- Mix data representation with processing logic
- Assume numeric sequences represent business relationships

## Further Reading

- [Clean Code: A Handbook of Agile Software Craftsmanship](https://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882)
- [Refactoring: Improving the Design of Existing Code](https://martinfowler.com/books/refactoring.html)
- [Code Complete: A Practical Handbook of Software Construction](https://www.amazon.com/Code-Complete-Practical-Handbook-Construction/dp/0735619670)

## Contributing

When contributing to this example, please:
1. Keep examples generic and applicable to any domain
2. Focus on fundamental programming principles
3. Provide clear before/after comparisons
4. Include unit tests for any new examples
5. Update documentation to reflect changes

## License

This educational example is provided under the AGPLv3 License.

âš ï¸ AI Disclosure: 
This project includes code generated with assistance from Large Language Models (LLMs) including Claude. 
Use at your own discretion.



===============================================================================
EXPORT COMPLETED: 09/18/2025 15:48:48
Total Files Exported: 9
Output File: C:\Users\kushal\source\repos\AvoidMagicNumbers\llm\dump.txt
===============================================================================
